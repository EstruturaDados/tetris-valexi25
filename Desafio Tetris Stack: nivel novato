#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// --- DEFINIÇÕES E CONSTANTES ---
#define TAMANHO_MAX 5 // Capacidade da fila (Próximas peças)

// Estrutura que representa uma peça do Tetris
typedef struct {
    char nome; // Tipo: 'I', 'O', 'T', 'L', etc.
    int id;    // Identificador único da ordem de criação
} Peca;

// Estrutura de Controle da Fila
typedef struct {
    Peca itens[TAMANHO_MAX];
    int inicio;      // Índice do elemento na frente (para remover)
    int fim;         // Índice onde será inserido o próximo (final)
    int quantidade;  // Quantos elementos existem atualmente
} FilaPecas;

// Variável global para gerar IDs únicos sequenciais
int contadorGlobalIds = 0;

// --- PROTÓTIPOS DAS FUNÇÕES ---
Peca gerarPeca();
void inicializarFila(FilaPecas *f);
int enfileirar(FilaPecas *f); // Enqueue
int desenfileirar(FilaPecas *f); // Dequeue
void exibirFila(FilaPecas f);

// --- FUNÇÃO PRINCIPAL ---
int main() {
    FilaPecas minhaFila;
    int opcao;
    
    // Inicializa o gerador de números aleatórios
    srand(time(NULL));

    // Configura a fila inicial
    inicializarFila(&minhaFila);

    printf("=== BEM-VINDO AO TETRIS STACK ===\n");
    printf("Simulador de Fila de Pecas Futuras\n");

    do {
        // Exibe o estado atual da fila
        exibirFila(minhaFila);

        // Menu de Opções
        printf("\nOpcoes de acao:\n");
        printf("1 - Jogar peca (Dequeue)\n");
        printf("2 - Inserir nova peca (Enqueue)\n");
        printf("0 - Sair\n");
        printf("Escolha: ");
        scanf("%d", &opcao);

        printf("\n-------------------------------\n");
        switch (opcao) {
            case 1:
                desenfileirar(&minhaFila);
                break;
            case 2:
                enfileirar(&minhaFila);
                break;
            case 0:
                printf("Encerrando simulacao...\n");
                break;
            default:
                printf("Opcao invalida! Tente novamente.\n");
        }
        printf("-------------------------------\n");

    } while (opcao != 0);

    return 0;
}

// --- IMPLEMENTAÇÃO DAS FUNÇÕES ---

// Função auxiliar para criar uma peça aleatória
Peca gerarPeca() {
    Peca novaPeca;
    char tipos[] = {'I', 'O', 'T', 'L', 'J', 'S', 'Z'};
    
    // Sorteia um índice de 0 a 6 para escolher o tipo
    novaPeca.nome = tipos[rand() % 7];
    
    // Atribui ID e incrementa o contador global
    novaPeca.id = contadorGlobalIds++;
    
    return novaPeca;
}

// Inicializa a fila preenchendo-a completamente para o início do jogo
void inicializarFila(FilaPecas *f) {
    f->inicio = 0;
    f->fim = 0;
    f->quantidade = 0;

    // Preenche a fila inicial (regras do Tetris geralmente começam com a fila cheia)
    printf("Gerando pecas iniciais...\n");
    for (int i = 0; i < TAMANHO_MAX; i++) {
        enfileirar(f);
    }
}

// Adiciona uma peça ao final da fila (Enqueue)
// Retorna 1 se sucesso, 0 se falha (fila cheia)
int enfileirar(FilaPecas *f) {
    if (f->quantidade >= TAMANHO_MAX) {
        printf("[AVISO] A fila esta cheia! Jogue uma peca antes de adicionar outra.\n");
        return 0;
    }

    Peca p = gerarPeca();

    // Insere na posição 'fim'
    f->itens[f->fim] = p;

    // Atualiza o índice 'fim' de forma circular
    // Se fim for 4, (4+1) % 5 vira 0. A fila dá a volta.
    f->fim = (f->fim + 1) % TAMANHO_MAX;
    
    f->quantidade++;
    printf("Nova peca adicionada: [%c %d]\n", p.nome, p.id);
    return 1;
}

// Remove e "Joga" a peça da frente (Dequeue)
// Retorna 1 se sucesso, 0 se falha (fila vazia)
int desenfileirar(FilaPecas *f) {
    if (f->quantidade == 0) {
        printf("[ERRO] A fila esta vazia! Nao ha pecas para jogar.\n");
        return 0;
    }

    Peca p = f->itens[f->inicio];

    // Atualiza o índice 'inicio' de forma circular
    f->inicio = (f->inicio + 1) % TAMANHO_MAX;
    
    f->quantidade--;
    printf(">>> Voce jogou a peca: [%c %d] <<<\n", p.nome, p.id);
    return 1;
}

// Exibe visualmente o conteúdo da fila
void exibirFila(FilaPecas f) {
    printf("\nEstado Atual da Fila (%d/%d):\n", f.quantidade, TAMANHO_MAX);
    
    if (f.quantidade == 0) {
        printf("[ Fila Vazia ]\n");
        return;
    }

    // Loop para percorrer a fila circular corretamente
    // Começa no índice 'inicio' e avança 'quantidade' vezes
    for (int i = 0; i < f.quantidade; i++) {
        // Calcula a posição real no vetor usando aritmética modular
        int indiceReal = (f.inicio + i) % TAMANHO_MAX;
        
        printf("[%c %d] ", f.itens[indiceReal].nome, f.itens[indiceReal].id);
        
        if (i < f.quantidade - 1) {
            printf("-> "); // Seta para indicar a ordem
        }
    }
    printf("\n(Frente)                        (Fim)\n");
}
